---
layout: post
title:  "CRNC.work Social Production MOOC"
date:   2015-08-31 12:00:00
categories: Networking Technoloogy
---


Social production or [commons-based peer production (CBPP)](https://en.wikipedia.org/wiki/Commons-based_peer_production) is primarily about a productivity-driven collaborative culture.  The point of CBPP is greater productivity and speed, but useful by-product is that [for those who can handle it] work is not a waste, but is actually fun.   

CBPP covers many different types of intellectual output, from open source software to data APIs to human-readable blogs, wikipedias, peer-reviewed articles and more. CBPP has been enabled by technoloogies that are primarily internet-based to allow for coordination between distributed groups of individuals working on a single project or even crowds of volunteers working on something like Wikipedia.  An absolutely fundamental building block of CBPP has been some form of revision-controlled process to track and rollback and attribute and merge different contributions to produce a coherent, unified intellectual product.  Making one's professional contribution more valuable has always required serious effort to listen but it is increasingly necessarily to "think like a native speaker" when it comes distributed revision-control systems like Git to understand and make sense of the chaotic combinations of simultaneous ideas and revisions.  Make knowledge more relevant is matter of more genuinely being plugged into the NETWORK.  

If you want to understand workflow, you really need to understand the [Architecture of Open Source Projects](http://aosabook.org/en/index.html) books and also follow the [blog](http://aosabook.org/blog/).  The big lesson from this material is another version of Conway's Law ... companies like IBM, Microsoft, Google or Facebook want to and can hire the best and brightest, but the record of performance from companies after they have hired the best and brightest is pretty dismal.  It takes more than incredibly bright people ... although there is absolutely nothing wrong with bright people ... consequential open source software projects were delivered because the workflows that were used allowed "ordinarily bright" people to create something that transcended the boundaries placed upon the best and brightest trapped inside the confines of IBM, Microsoft, Google or Facebook.

**Volume I**
1.  [Scalable Web Architecture and Distributed Systems](http://aosabook.org/en/distsys.html) by [Kate Matsudaira](http://katemats.com/) ... it is necessary to decouple [things like internal device physics and] functionality [of the components] and think about each part of the system as its own abstract service with a clearly defined interface ... the interfaces are critical; because they tend to represent organizational boundaries AND, in turn, they drive the requirements of the component parts of the system.  Systems don't build themselves; they get built by humans who are incentivized or employed/directed by someone ... as you read this great article and maybe dig deeper into some of the backround on what people were thinking about five, ten or fifteen years ago, like [The Pathology of Big Data](http://queue.acm.org/detail.cfm?id=1563874), try to imagine what it was like to be involved doing that systems engineering and what kind of [communication] challenges those people faced in specifying and developing those critical interfaces ... obviously, [being in the trenches, developing distributed databases at any kind of scale has its set of interesting own challenges](https://aphyr.com/posts) ... and some times, the challenges are not at all abstract, technical, scientific or even involve data -- I recall, for example, how the whole open source MySQL team was saying prayers for a critically important Serbian collaborator as we watched the reports of the NATO bombing from the MySQL listserv ... in the era of GitHub, it's important to remember that essential open source projects, like MySQL, were not at very "fault tolerant" at all when it came to the loss of critical data ... or developers.

2.	[Firefox Release Engineering]	by [Chris AtLee, Lukas Blakk, John O'Duinn, and Armen Zambrano Gasparnian]

3.	[FreeRTOS] by [Christopher Svec]

4.	[GDB] by [Stan Shebs]

5.	[The Glasgow Haskell Compiler] by [Simon Marlow and Simon Peyton-Jones]

6.	[Git](http://aosabook.org/en/git.html)	by [Susan Potter](https://github.com/mbbx6spp) ... it is terribly important to understand the circumstances in which the Git project was started in the Linux Kernel Community.  The Linux kernel was BEYOND just UNUSUAL ... it was revolutionary, compared to work done by most commercial software drones on other development projects at that time.  Aside from fighting in a revolution-in-progress and not really getting any respect for the significance of the effort, the Linux Kernel Community ALSO had technical challenges in its large number of committers and the enormous variance of contributor involvement and their knowledge of the existing codebase ... and those technical challenges posed a very severe threat to consolidation of the revolution's victories -- as people used Linux in new, different and a more distributed manner ways, the Linux kernel had to continue to evolve [more rapidly than before, in spite of its growing complexity] and speed of development mattered ... so Git was born of a NEED for what we now know as Git.  From the outset, Torvalds had one philosophical goal for Git—to be the anti-CVS PLUS three usability design goals:

* Distributed workflows [for the especially distributed development needs of Linux]

* Safeguard against [malicious or inadvertent] corruption of data

* Deliver high performance [for the Linux kernel community, the toughest customers on the planet]

It is essential to think about what these goals meant, given the often repeated mantra of Torvalds, the Linux kernel community and Git community: **"Make your code readable and sensible, and do NOT try to be clever.""  Git was ESSENTIAL!!!** ... none of the Git requirements were simply nice-to-have "cool" features that we are accustomed to finding in proprietary software [and even some open source software that still imitates the lowest-denominator-thinking and feature-bloat of proprietary packages].  Many [maybe most Github users] are tempted by the free availability of Git to think of Git as not just another useful piece of free software, but they don't really GET that [Git is really serious heavy-weight, grown-up, professional tool](http://git-scm.com/book/en/v2) that is NECESSARY for building serious, heavy-weight, grown-up professional applications ... Git is sensible and unclever and only as complicated as it absolutely needs to be; Git is ESSENTIAL. 


7.	[GPSD] by	[Eric Raymond]

8.	[The Dynamic Language Runtime and the Iron Languages]	by [Jeff Hardy]

9.	[ITK]	by [Luis Ibanez and Brad King]

10.	[GNU Mailman]	Barry Warsaw

11.	[matplotlib] by [John Hunter and Michael Droettboom]

12.	[MediaWiki]	by [Sumana Harihareswara and Guillaume Paumier]

13.	[Moodle] by [Tim Hunt]

14.	[nginx] by [Andrey Alexeev]

15.	[Open MPI] by [Jeff Squyres]

16.	[OSCAR]	by [Jennifer Ruttan]

17.	[Processing.js] by [Mike Kamermans]

18.	[Puppet] by	[Luke Kanies]

19.	[PyPy] by	[Benjamin Peterson]

20.	[SQLAlchemy] by	[Michael Bayer]

21.	[Twisted] by	[Jessica McKellar]

22.	[Yesod] by	[Michael Snoyman]

23.	[Yocto]	by [Elizabeth Flanagan]

24.	[ZeroMQ] by	[Martin Sústrik]

**Volume II**
1.	Asterisk	Russell Bryant
2.	Audacity	James Crook
3.	The Bourne-Again Shell	Chet Ramey
4.	Berkeley DB	Margo Seltzer and Keith Bostic
5.	CMake	Bill Hoffman and Kenneth Martin
6.	Eclipse	Kim Moir
7.	Graphite	Chris Davis
8.	The Hadoop Distributed File System	Robert Chansler, Hairong Kuang, Sanjay Radia, Konstantin Shvachko, and Suresh Srinivas
9.	Continuous Integration	C. Titus Brown and Rosangela Canino-Koning
10.	Jitsi	Emil Ivov
11.	LLVM	Chris Lattner
12.	Mercurial	Dirkjan Ochtman
13.	The NoSQL Ecosystem	Adam Marcus
14.	Python Packaging	Tarek Ziadé
15.	Riak and Erlang/OTP	Francesco Cesarini, Andy Gross, and Justin Sheehy
16.	Selenium WebDriver	Simon Stewart
17.	Sendmail	Eric Allman
18.	SnowFlock	Roy Bryant and Andrés Lagar-Cavilla
19.	SocialCalc	Audrey Tang
20.	Telepathy	Danielle Madeley
21.	Thousand Parsec	Alan Laudicina and Aaron Mavrinac
22.	Violet	Cay Horstmann
23.	VisTrails	Juliana Freire, David Koop, Emanuele Santos, Carlos Scheidegger, Claudio Silva, and Huy T. Vo
24.	VTK	Berk Geveci and Will Schroeder
25.	Battle For Wesnoth	Richard Shimooka and David White

**The Performance of Open Source Applications**
1. High Performance Networking in Chrome	Ilya Grigorik
2.	From SocialCalc to EtherCalc	Audrey Tang
3.	Ninja	Evan Martin
4.	Parsing XML at the Speed of Light	Arseny Kapoulkine
5.	MemShrink	Kyle Huey
6.	Applying Optimization Principle Patterns to Component Deployment and Configuration Tools	Doug C. Schmidt, William R. Otte, and Aniruddha Gokhale
7.	Infinispan	Manik Surtani
8.	Talos	Clint Talbert and Joel Maher
9.	Zotonic	Arjan Scherpenisse and Marc Worrell
10.	Secrets of Mobile Network Performance	Bryce Howard
11.	Warp	Kazu Yamamoto, Michael Snoyman, and Andreas Voellmy
12.	Working with Big Data in Bioinformatics	Eric McDonald and C. Titus Brown

Some observations from this blog...


# Collaboration does not just happen; supporting a holarchic, self-organizing, self-empowering team takes the diligent effort of an aggressive [campaign](http://dictionary.reference.com/browse/campaign)
Campaigning is about putting yourself out there and taking the chance that someone doesn't like you. Fear prevents the ability to take risks, which dampens experimentation and potential is not be realized. We drive out fear by substituting leadership and that means STEPPING FORWARD in a meaningful way -- that means applying business intelligence and finding the most appropriate battlegrounds for your campaign.

# Encourage a quality-driven leadership mindset in ALL behaviors; inhabit the mindset of leadership
A culture of collaborative leadership must be practiced mindfully and continually reinforced. Every aspect of execution matters. Quality leadership is not for sissies or people who resort to distractions, crutches and escapism when the going gets tough; collaborative thinking must be reflected in ALL practices, all processes, all logistics, all actions ... nonstop, 24X7.

# Lead by promoting communication, collaboration and competition among team members
Stop wasting your time on people who will not help themselves. Team members must be able to get along, to interact and challenge one another AND each team member must be capable of getting the team unstuck when the team gets stuck.  Get along and getting unstuck is about THINKING and especially about trying to think differently in order to understand other points of view ... it is important to work at understanding other points of view AND it also important to limit the time wasted on those who simply never try to understand others.  

# Motivate and energize your team in ways that channel conflict
Doing hard things is frustrating and inevitably leads to disagreements and conflict. It is necessary to use humor, teasing, practical jokes, dialogue and just getting out, giving things a try, traveling and actually doing different things to promote thinking differently ... it's not bad to have conflict; it's bad to give up, hunker down, stick to old ways and blame others for the conflict [that is a result of frustration that will be encountered in doing serious, challenging hard research and development].

# Work with large national or even globally distributed teams
Travel is still necessary, but should not be the first resort ... you can only be one place at a time; work where you can most comfortably get things accomplished without getting sidetracked. Greater proficiency in the digital realm is increasingly necessary. Work will continue to change and you will have to adapt. Get used to adapting to change and profiting from change and speed of adaptation; thinking DIFFERENT about distributed work is more necessary now than it ever has been in human history.

**Distributed workflow must be especially LEAN ... [use D.O.W.N.T.I.M.E. to see waste](https://docs.google.com/presentation/d/15TSMzjMqcR4-7Dmnsymgq8yRCHGbZbOEMRHbcUtTnV8/edit?usp=sharing) ... become a master of kanban techniques**

* Set clear, manageable objectives ... inbox, analyze, dev, test, *crunch*

* Limit WIP ... focus on the ONE big thing that matters most, do it first

* Manage flow ... 5S WIP, shine, sort, simplify, standardize, sustain

* Make process simple, routine and explicit so no one drifts off the trail

* Implement feedback loops ... repo chat, face-to-face, but NOT meetings

* Evolve collaboratively ... improve your ability to work more socially


# Bear down on workflow-as-code discipline and practice agile mechanics if only just to get practice
Some days, often in fact, it is important to just stay at it, to just try to do something shippable [even if it is teensy] ... stick with a workflow, try things and persevere ... when professionals find themselves in what feels like a slump, they just smile and work harder on the basics, bear down and focus because they know that tougher times weed out the weaklings.  It is particularly necessary during tough times to find a way to get things out there, to SHIP.  Patton reputabaly said: “A good plan violently executed now is better than a perfect plan next week”.  That is why code SPRINTS, for example, have radically-constrained goals in order to focus.  Make your code readable and sensible, and don't try to be clever.  All activities (design, code, integrate, test) are performed to create a one particular feature in one sprint.  We want sprints to be SMALL because with incremental additions to feature sets we can do a better job of ensuring that we have achieved a solid return on investment (ROI) delivered from each sprint ... and if not, we can make adjustments.
